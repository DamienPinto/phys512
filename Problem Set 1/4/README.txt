Answer to 4: 
As can be seen in "R4_z0-8.png", which is the field computed for a shell of radius 4 for 0 <= z <= 8, both programs can plot the general profile fairly well. Even if one uses the matplotlib plot produced by charged_shell_integration.py to zoom in intensely on the z=4.0 section, both lines, or both evaluations of E, appear to coincide and stay well-behaved.

However when looking at the console, this impression is not maintained. My variable interval integration program hits z=4.0 and has some problems (console_message_at_z4.png) begins to exclaim that the boundaries of integration it is evluating are identical. This might indicate, if I had to speculate, that it has subdivided the area of integration so many times that it has hit an interval size dx where x_i and x_f look identical. In those cases I tell it to return 0s.

Looking at the comparison of the absolute errors/uncertainties between my program and scipy.integrate.quad, we can also see that quad's error is consistently lower than my program's. Although the errors can be adjusted to be of similar magnitudes (R4_z0-8_absolute_error_comparison_tol1e-8.png), at z=4.0 it still seems scipy has the upper hand. Zooming into the errors at that spot (R4_z0-8_absolute_error_comparison_zoomed_z4.png) shows that my program defaulted to 0, but scipy managed some way to evaluate the field and produce a finite and non-zero error, indicating it might be equiped to address these types of finite singularities.